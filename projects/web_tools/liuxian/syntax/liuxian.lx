
这是我关于编程语言的想法, 拼凑和试探性质的
首先仿照`lisp`对于优先级做出定义
1, 圆括号`(代码)`内部会先于外部被执行
2, 缩进可以代替圆括号, 下两者等效
	[1 2 3].each |x|
		print x
	[1 2 3].each |x| (print x)
3, 允许多重缩进, 且行头行尾括号可省略
	(f1 (f2 (f3 p1)
			p2)
		p3)
	f1 (f2 (f3 p1
			p2
		p3
然后类型, 可在脚本开头用正则声明类型
将带特殊符号的片段识标记为给定名称的类型
	[a-zA-Z_]+         : var             -> 变量
	\d+                : 42              -> 整型
	\d+\.\d*           : 42.42           -> 实数
	\d+\/\d+           : 4/2             -> 分数
	[1-9]*&[1-9]*      : 8&88            -> 双三数
	'\unnn             : 'c'             -> 字符?
	\"[^\"]*\"         : "string"        -> 字符串
	$\w                : $Anger          -> 类型 A
	\w#                : new#            -> 类型 B
	/.*[^\\]/          : /x/             -> 正则?
然后定义的函数就有类型匹配, 类比语言
前面定义优先级, 然后函数形式和输出结果
	f @ 2 :: Int:a f1 Int:b = Int:c
		a^2 + b^2 = c^2 || error "非整数"
		c >= 0 || error "负数"
	3 f1 4
	# 将返回 5
表达式串联的话, 也可以省略类型可以抉择的括号
	f @ 2 :: Int:a f2 = Str:b
		b ~ int2str a
	f @ 2 :: Str:b f3 = Float:c
		c ~ str2float b
	f3 f2 42
	# f3 判断其后 f2 类型不对, 于是等待后边更多执行
级联方法采用管道符改写, 下面等价
	($ '#elem').focus().val('').append "<br/>"
	$ "#elem" | focus | val "" | append "<br/>"
