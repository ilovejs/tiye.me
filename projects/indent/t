
(柳线)语言语法要点
	减少括号, 用缩进表示嵌套, 缩进层次不止一级
	每个表达式都有返回值, 返回值作为新的表达式的部分

注释
	## 注释到行尾
数字
	1
	1'59 ## 小数点放在上面
	-9
字符
	`d
	`\n ## 换行
	`\96 ## ASCII 代码 96
字符串
	& 768
	&(768)
	&"768"
	&-768-
	string 768
	string(768)
正则表达式
	~/rex/
	~'rex'
	~
		rex
列表
	$ 0 1 2 3
	$ 0
		1
		2
		3
取出字符串/ 列表中取某个值
	$'hello'.3
	($ 0 1 2 3 ).3
索引
	$ fst:1 snd:2 thd:3
	$
		fst : 1
		snd : 2
		thd : 3
取出索引中某个值
	(# fst:2 snd:2 thd:3 ).fst
赋值, 括号在换行之后不用补全
	num : 1
	str : &
		hello world
	str : &"hello world"
	arr : ($ 1 2 3
	ndx : (@ fst:1
自增自减
	num + 1
	num - 1
	str + ($ added
运算, 末尾括号不必补全
	+ 1 2
	/ 3 5
	+ 'hello' ($ world
	+ arr (# 4 5 6
字符串/ 列表/ 索引而言
	加法补充, 减法从末尾减去,
	乘数字加倍, 乘列表做排列组合
	除法清除所有匹配
	取余从开头除去匹配
判断, 三值逻辑
	1>2) (echo $'true'
		echo $'false'
		echo $'undefined'
迭代
	each (# 0 1 2 3 4) item (echo item
递归
	f x :
		x > 1) + f(- x 1) f(- x 2)
		x = 1) 1
		x = 2) 1
定义函数和类型
	# f n : n
	f x : (+ x 1
多层缩进f(n,(f1 n1 n2), n3)
	f n (f1
			n1
			n2
		n3
逗号将两个缩进相同的行写在一行
	f n (f1
			n1, n2
		n3



后面都是草稿了..

运算
	a + b ## a 的值是改变的, 返回 a
	+ a b ## a 的值不变, 返回和
	sum : a+b ## (+)附近没有空格, 因而比空格之外优先结合
	sum1 : a.+.b ## (.)用来是另一种比空格优先结合的标记
	sum2 : +.a.b ## 用函数的写法, 函数名前置, 中置是语法糖
	str2 : str+str ## (+)对于字符串是拼接
	str3 : str-str ## (-)对从前者末尾减去后者
	str4 : str/str ## (/)从前者中除去所有匹配的后者
复杂表达式比如
	## num1=(a*(a+1))
	num1 : a.*.+a1
	## num2=a*(a*(a+1))
	num2, :, a * a.*.a+1
	## 上面对应一种简写
	num5 : a, a * a.*.+a1
	## num3=a*(a*(a+1)) 另一种
	num3 :
		* a
			* a +.a.1 ## 分开的缩进表示优先级关系
	## num3=a*(a*(a+1)) 另一种
	num3 : a*
			a*a+1 ## 注意这里用了两层缩进
		## 因为(a*)后面截断, 换行接上的函数不确定属于哪一层优先级
		## 于是用缩进个数指定到对应优先级
	## num4=[(a*),a*a+1]
	num4 : a*
		a*a+1 ## 相当于赋值给 num4 一个列表
		## 但前面赋值了(a*)是函数, 会出错
查看变量
	show b+c ## 显示"hellohello world"
判断, 布尔值作为函数, 后面三个参数, 分辩执行(对/错/未定义)的操作
	a=2, show `\等于` 2` 哦! , show `\不等于` 2 , show `\未定义变量` a
	## 逗号后面的空格是多余的, 为了美观
	## 用缩进整个可以这样写
	a = 2, show `\等于2
		show `\不等于2
		show `\未定义a
迭代
	`ls\1.2.3.4.5 each item, show item
循环
	a:0; s:0; loop_while a<100
			s+a; a+1 ## 必须用分号, 因为是两个语句
	## 或者另一种结构
	a:0
	s:0
	loop_while a<100 s+a a+1
函数
	# f Num : Num ## (#)开头加上类型
	f x : x+2 ## 借鉴 Haskell
	# 来定义 fabonacci
	# f Num : Num
	f x :, f.x-1

下面的例子不完整:

(defn fib [n]
	(if (= n 0) 0
		(if (= n 1) 1
			(+ (fib (- n 1)) (fib (- n 2))))))

defn fib list.n
	if n=0 0
		if n=1 1
			+ fib.n-1 fib.n-2

(defn lazy-seq-fibo
	([]
		(concat [0 1] (lazy-seq-fibo 0 1))) 
	([a b]
		(let [n (+ a b)]
			(lazy-seq
				(cons n (lazy-seq-fibo b n))))))
defn lazy-seq-fibo
	





(defn less-than-four-million? [n] (< n 4000000))
(println (reduce +
	(filter even?
		(take-while less-than-four-million? (lazy-seq-fibo)))))

defn less_than_four_million list.n n<4000000
println reduce.+
		filter even
			take_while_four_million lazy_seq_fibo


(def big-num-str
	(str "731671765313306249192"))

def big_num_str
	str `\31671765313306249192
