			<title>			scheme笔记			</title>			<style>			body{
	background: hsl(0,96%,96%);
	font-size: 13px;
	padding: 26px 130px;
	line-height: 26px;
}
body>code, pre{
	padding: 0px 3px;
	margin: 0px 3px;
	background: hsl(0,94%,95%);
	border: 1px solid hsl(0,96%,86%);
}
p{
	margin: 0px;
}
pre{
	-moz-tab-size: 4;
	margin: 0px;
	width: 600px;
}
body>*{
	margin: 0px;
}
a{
	color: hsl(240,40%,50%);
	text-decoration: none;
}			</style>			<br/>打算学<code>Scheme</code>, 搜了不少尝试去理解, 中文资源不如<code>JS</code>多<br/><code>IBM</code>社区<code>5+</code>篇文章, 下面两篇介绍语法方面比较清晰<br/><a href='http://www.ibm.com/developerworks/cn/linux/l-schm/index1.html'>www.ibm.com/developerworks/cn/linux/l-schm/index1.html</a><br/><a href='http://www.ibm.com/developerworks/cn/linux/l-schm/index2.html'>www.ibm.com/developerworks/cn/linux/l-schm/index2.html</a><br/>关于历史掌故可以看下面这篇了解下, 比较乱, 我没有细看<br/><a href='http://blog.chinaunix.net/space.php?uid=20106293&do=blog&id=142113'>blog.chinaunix.net/space.php?uid=20106293&do=blog&id=142113</a><br/><code>scm</code>的规范简介有力, 真的很短, 入门后去看下<br/>直接<code>Google</code>就能找到 "算法语言<code>Scheme</code>修订<code>5</code>报告"<br/>教程英文的不少, 中文有本<code>SICP</code>的翻译, 算清晰, 爱问搜索有<br/>我搜到<code>3</code>份英文教程, 打算只看最简短的第一份了<br/><code>Teach Yourself Scheme in Fixnum Days</code><br/><a href='http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html'>www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html</a><br/><code>How to Design Programs: DrScheme Companion</code> <a href='http://www.htdp.org/'>www.htdp.org/</a><br/><code>The Scheme Programming Language</code> <a href='http://www.scheme.com/tspl3/'>www.scheme.com/tspl3/</a><br/>我参照的这份文档只为学会用 scm 解决问题, 大不算深入<br/>然后我很想用上<code>Scheme</code>的缩进语法, 希望入门后去看 <br/><a href='http://srfi.schemers.org/srfi-49/srfi-49.html'>srfi.schemers.org/srfi-49/srfi-49.html</a><br/><br/>记得例子不少用<code>guile</code>来运行<code>scm</code>的, 在脚本开头加两行并可以空行<br/><pre><code>#! /usr/bin/env guile<br/>!#</code></pre>系统没有 guile 可以在 Ubuntu 安装, 我装的是 1.8 版本<br/>然后脚本我不重复了, 开头缩进是笔记格式, 代码参考原文<br/><pre><code>;The first program<br/>(begin<br/>	(display "Hello")<br/>	(newline))</code></pre>分号开头进行注释, <code>begin</code>表示后边多个模式<br/><code>display</code>是向<code>console</code>输出, <code>newline</code>是输出新的换行<br/>教程说的<code>mzscheme</code>不清楚, <code>Ubuntu</code>里面用的<code>guile</code><br/>实际上我用的命令是<code>$ rlwrap guile</code><br/>然后输入<code>load "hi.scm"</code>(点钱目录文件名)运行该脚本<br/><code>guile</code>中的<code>prompt</code>是<code>guile></code>, 这里直接输入代码<br/>在<code>prompt</code>中输入<code>"hi"</code>会直接输出内容<br/>两种方式有区别, 向<code>console</code>输出对于函数是种副作用<br/>而<code>"hi"</code>则是计算得到结果的<br/>文章约定<code>=></code>表示模式运算后给出结果<br/>可以用<code>(exit)</code>退出<code>guile</code>命令行, <code>Linux</code>常快捷键<code>C^d</code><br/>运行脚本可以用<code>guile -s hi.scm</code><br/><br/><p><b><code>scm</code>有布尔, 数值, 字符, 符号几个数据类型</b></p>真: <code>#t</code>, 假: <code>#f</code>, 判断是否布尔类型: <code>boolean? #t</code><br/>否定: <code>(not #t) ;=> #f</code><br/><code>scm</code>中数值类型有整数, 分数, 实数, 复数<br/>各自有<code>number? complex? real? rational? integer?</code> 判断<br/>整数未必十进制, 前缀<code>#b #o #x</code>分别表示二, 八, 十六进制<br/>比如<code>#b100</code>是二进制的<code>100</code>, 十进制的<code>4</code><br/>判断大小是否相等用<code>(eqv? 2 #b10) => #t</code><code>(eqv? 2 2.0) => #f</code><br/>这个广义的判别函数对于不同类型不会报错<code>(eqv? 2 #f) => #f</code><br/>另外有个针对数值的判别符<code>(= 42 42.0) => #t</code><br/>而这个判别符对于数值外内容会报错, 比如<code>(= 2 #f)</code><br/>对于数字的大小判断还有<code>> < >= <=</code>可用<br/>运算符号有<code>+ - * /</code>, 都支持一个或多个参数<br/>其中除法结果是分数<br/><code>(expt 2 3)</code>表示乘方, 只有两个参数<br/><code>min max abs exp atan sqrt</code>等都可以推测<br/><code>scm</code>的字符以<code>#\</code>开头比如<code>#\c</code>是字符<code>c</code><br/>一般是在后面跟一个字符, 但也有用多个字母描述的比如<br/><code>#\newline #\tab #\space</code>, 也有<code>#\ </code>表示空格<br/>字符的判别: <code>char? #\c ;=> #t</code>, 字符还有大小的判别<br/><code>char<? char<=? char=? char>=? char>?</code><br/>为忽略大小写用<code>(char-ci=? #\A #\a) => #t</code>, 以此类推<br/>字母大小写转换用<code>char-downcase char-upcase</code><br/>前面这些比如<code>#t 42 #\c</code>自求值的内容<br/>符号被输入到解释器里, 给出运算结果一般就是本身<br/>符号类型不同, 因为同样的内容常被用作变量标识符<br/>意味着那会被计算, 并返回计算结果的内容<br/>但符号依然是基本的数据类型, 可以和其他类型交换<br/>在<code>scm</code>里用上<code>(quote xyz) => xyz</code>标记符号<br/>符号非常常用, 于是有了简写<code>'E</code>相当于<code>(quote E)</code><br/>符号的表示以不被混淆为准, <code><=></code>和'$!#*'都行<br/>但像这些<code>#t "aString" -i</code>就不行了<br/>可以用<code>(symbol? 'xyz)</code>判别<br/>注意<code>scm</code>里对大小写不敏感, 这里不例外<br/>接着可以定义符号为变量<code>(define xyz 9)</code><br/>在解释器里输入就会直接返回内容了<code>xyz ;=> 9</code><br/>或者用<code>(set! xyz #\c)</code>这样<br/>复合数据类型由数据类型俺结构组合而成<br/>字符串是自求值的<code>"Hello" => "Hello"</code><br/>该程序由一系列字符组成<code>(string #\H #\e #\l #\l #\o)</code><br/>用<code>(string-ref "abcd" 1)</code>取出序号<code>1</code> 的元素<br/>用<code>(string-append "a" "b" "c")</code>来组合新的字符串<br/>可新建指定长的空字符串<code>(make-string 3) ;=> "\x00\x00\x00")</code><br/>如果<code>(define s (make-string 3))</code><br/>那么再给<code>s</code>赋值就注意不能越界<br/><code>(string-set! s 0 #\s)</code>用来修改指定序号的字符<br/>向量可以容纳各种类型, 包括向量自身<br/>定义向量: <code>(vector 1 2 3) ;=> #(1 2 3)</code><br/>也可以直接使用<code>#(1 2 3)</code>产生向量<br/>类似有<code>(make-vector 5)</code>来生成限定长度的向量<br/>类似有<code>vector-ref vector-set vector?</code><br/><p><b>点对用来组合任意两个值, 前者称<code>car</code>, 后者<code>cdr</code></b></p>组合两者的程序是<code>(cons 1 #\t) ;=> (1 . #\t)</code><br/>简洁的定义的方式<code>'(1 . #\t)</code><br/><pre><code>(define x '(1 . #\t))</code></pre>取出内容通过<code>(car x)</code>或者<code>(cdr x)</code><br/>设置: <code>(set-car! x)</code>和<code>(set-cdr! x)</code><br/><pre><code>(define y (cons (cons 1 2) 3)) ;=&gt; ((1 . 1.0) . 2))<br/>(define y (cons 1 (cons 2 3))) ;=&gt; (1 2 . 3)</code></pre><code>(cdr (car y))</code>可以简化成<code>(cdar y)</code>最多四层<br/><pre><code>(cons 1 (cons 2 (cons 3 (cons 4 5)))) ;=&gt; (1 2 3 4 . 5)</code></pre>有个空的点对<code>'() ;=> ()</code><br/><pre><code>'(1 . (2 . (3 . (4 . ())))) ;=&gt; (1 2 3 4)<br/>(cons 1 (cons 2 (cons 3 (cons 4 '())))) ;=&gt; (1 2 3 4)</code></pre>还有个程序: <code>(list 1 2 3 4) ;=> (1 2 3 4)</code><br/>还有: <code>'(1 2 3 4) ;=> (1 2 3 4)</code><br/><pre><code>(define y (list 1 2 3 4))<br/>(list-ref y 0) ;=&gt; 1<br/>(list-ref y 3) ;=&gt; 3<br/>(list-tail y 1) ;=&gt; (2 3 4)<br/>(list-tail y 3) ;=&gt; (4)<br/>(pair? '(1 . 2)) ;=&gt; #t<br/>(pair? '(1 2)) ;=&gt; #t<br/>(pair? '()) ;=&gt; #f<br/>(list? '()) ;=&gt; #t<br/>(null? '()) ;=&gt; #t<br/>(list? '(1 2)) ;=&gt; #t<br/>(list? '(1 . 2)) ;=&gt; #f</code></pre>字符串和数值间通过<code>ASIIC</code>码互转, 其他较明显<br/><pre><code>(char-&gt;integer #\d) ;=&gt; 100<br/>(integer-&gt;char 50) ;=&gt; #\2<br/>(string-&gt;list "hello") ;=&gt; (#\h #\e #\l #\l #\o)<br/>(number-&gt;string 16) ;=&gt; "16"<br/>(string-&gt;number "16") ;=&gt; 16<br/>(string-&gt;number "hi") ;=&gt; #f<br/>(symbol-&gt;string 'symbol) ;=&gt; "symbol"<br/>(string-&gt;symbol "string") ;=&gt; string</code></pre>基于基数的转化, 比如下面基于八进制<br/><pre><code><code>(string-&gt;number "16" 8)</code></code></pre><code>scm</code>还有个过程类型<code>procedure</code>, 目前看到都是基本过程<br/>基本过程在环境被支持, 也有途径创建自己的过程<br/>另有种数据类型<code>port</code>端口, 关联文件和终端的输入输出<br/>比如<code>display</code>还有个隐含的参数, 表示输出的端口<br/><code>(display "Hello, World!" (current-output-port)</code><br/><br/><code>scm</code>解释器会探测每一个形式<code>(form)</code>首个符号<br/>如果那是过程, 就会将其余作为参数执行这个形式<br/>像<code>begin define set!</code>是一些特殊形式, 特殊行为<br/>用户可以通过<code>lambda</code>表达式创建过程<br/><pre><code>(lambda (x) (+ x 2))<br/>((lambda (x) (+ x 2)) 5) ;=&gt; 7<br/>(define add2 (lambda (x) (+ x 2)))<br/>(add2 4) ;=&gt; 6<br/>(define area<br/>	(lambda (length breadth)<br/>		(* length breadth)))<br/>(define area *) ;=&gt; 同上</code></pre><code>apply</code>可以运行一个过程, 并载入指定参数<br/>可以载入多个参数, 但必须要列表作为参数结尾<br/><pre><code>(define x '(1 2 3))<br/>(apply + x) ;=&gt; 2<br/>(apply + 1 2 3 x) ;=&gt; 12</code></pre><code>begin</code>用来俺顺序执行参数中的子形式<br/>而<code>lambda</code>内部也是顺序执行的:<br/><pre><code>(define display3<br/>	(lambda (arg1 arg2)<br/>		(display arg1)<br/>		(newline)<br/>		(display arg2))</code></pre><br/>条件语句<code>if</code>, <code>else</code>是隐含的<br/><pre><code>(if #t<br/>	(display "true"))<br/>(if (&gt; 1 0)<br/>	(display "true")<br/>	(display "false"))</code></pre><code>when</code>用来判断, 当为真, 按顺序执行子形式<br/><code>unelss</code>把<code>when</code>的条件取反, 然后顺序执行<br/>不过两者在<code>guile</code>里用不出来, 不考虑了<br/><code>cond</code>用于判别, 每个参数都有判别是和结果<br/>有可选的<code>else</code>, 相似有<code>case</code>, 看例子的括号<br/><pre><code>(define c #\c)<br/>(cond ((char&lt;? c #\c) -1)<br/>	((char=? c #\c) 0)<br/>	(else 1)) ;=&gt; 0<br/>(case c<br/>	((#\a) 1)<br/>	((#\c) 2)<br/>	(else 3))</code></pre><code>and or not</code>对应: 且, 或, 非<br/>不过在<code>guile</code>对于多个值或其他类型参数就要出错<br/><pre><code>(and #\t #\f) ;=&gt; #\f<br/>(or #\t #\f) ;=&gt; #\t</code></pre><br/><p><b><code>scm</code>的变量作用域是词法域, 静态作用域</b></p>全局变量不受局部变量的影响, 看例子<br/><pre><code>(define x 9)<br/>(define add 2 (lambda (x) (+ x 2)))<br/>x ;=&gt; 9<br/>(add2 3) ;=&gt; 5<br/>x ;=&gt; 9</code></pre>而<code>(set! x 20)</code>能对全局变量进行修改<br/><code>scm</code>会选取词法上(?)最近的变量进行使用<br/><pre><code>(define counter 0)<br/>(define bump-counter<br/>	(lambda ()<br/>		(set! counter (+ counter 1))<br/>		counter))<br/>(bump-counter) ;=&gt; 1<br/>(bump-counter) ;=&gt; 2</code></pre><code>let</code>可以新建局部变量, 遮盖全局变量, 注意写法<br/><pre><code>(define x 20)<br/>(let (<br/>	(x 1)<br/>	(y 2))<br/>	(list x y)) ;=&gt; (1 2)<br/>(let (<br/>	(x 1)<br/>	(y x))<br/>	(list x y)) ;=&gt; (1 20)</code></pre>考虑到<code>let*</code>还有下面的写法<br/><pre><code>(let* ((x 1)<br/>	(y x))<br/>	(+ x y)) ;=&gt; 2<br/>(let ((x 1))<br/>	(let ((x y))<br/>		(+ x y))) ;=&gt; 2<br/>(let ((cons (lambda (x y) (+ x y))))<br/>	(cons 1 2)) ;=&gt; 3</code></pre><code>fluid-let</code>会临时修改全局变量值, 过后复原<br/>但是这个在<code>guile</code>里头也是不对劲的(?)<br/>而<code>let</code>本身面对这样的过程处理不同<br/><pre><code>(define x 0)<br/>(define x+<br/>	(lambda ()<br/>		(set! x (+ x 1))<br/>		(display x)))<br/>(let ((x 20))<br/>	(x+)) ;=&gt; 1</code></pre><br/><p><b>递归, 调用自身, 转化条件, 设定边界, 看例子</b></p><pre><code>(define fractorial<br/>	lambda (n)<br/>		(if (= n) 1<br/>			(* n (fractorial (- n 1)))))<br/>(define is-even?<br/>	(lambda (n)<br/>		(if (= n 0) #t<br/>			(is-odd? (- n 1)))))<br/>(define is-odd?<br/>	(lambda (n)<br/>		(if (= n 0) #f<br/>			(is-even? (- n 1)))))</code></pre>其实<code>scm</code>已经内置<code>even? odd?</code>两个过程<br/>注意在局部变量实现<code>is-even? is-odd?</code>会有问题<br/>用<code>let</code>时<code>if</code>内部的<code>is-even? is-odd?</code>不能正确指向<br/>用<code>let*</code>时<code>if</code>内部的<code>is-odd</code>不能正确指向<br/>于是引入了新的过程<code>letrec</code>进行<br/><pre><code>(letrec ((local-even? (lambda (n)<br/>	(if (= n 0) #t<br/>		(local-odd? (- n 1)))))<br/>	(local-odd? (lambda (n)<br/>		(if (= n 0) #f<br/>			(local-even? (- n 1))))))<br/>	(list (local-even? 23) (local-odd? 23)))</code></pre><br/><br/>