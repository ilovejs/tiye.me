<html>
<head>
<title>Node.js Guide CoffeeScript</title>
<link rel="stylesheet" href="m.css"/>
</head>
<body>
<pre>
Node.Js 教程: http://nodebeginner.org/index.html
coffee 是 CoffeeScript, 对应 "$ node server.js" 的命令是 "$ coffee server.coffee"
如果不会写,就 "$ npm install js2coffee" 从 js 编译到 coffee 看看:
更多命令和教程参照, 但是好像有 bug: https://github.com/rstacruz/js2coffee
https://github.com/rstacruz/js2coffee/issues/54#issuecomment-1935144
命令 "$ cat << EOF | js2coffee" 然后粘贴 js, 再回车输入 EOF 回车..

原理看这个: http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-103-4/
整个使用 listen 方法时不能在 createServer 后空格, 否则报错没用 listen method,
为了习惯空格, 我把第一个左圆括号放到开头, createServer 返回的对象就有 listen 了,

http = require "http"
(http.createServer (request, response) ->
    response.writeHead 200, "Content-Type": "text/plain"
    response.write "hello world!"
    response.end ''
).listen 8888

保存为 server.coffee , 再命令: "$ coffee server.coffee", 访问 http://localhost:8888/
response.end 需要执行, 所以要传入参数或者 () , 我偷懒传入了空的字符.
coffee 中使用匿名函数作为参数, 执行匿名函数, 与教程中的例子对应:

excute = (someFunction, value) ->
    someFunction value
excute ((word) ->
    console.log word)
    "hello"

下面这样写也是可以的, 为什么用前面那种方式写呢? 好像是为了 node 更自然之类...

http = require "http"
onRequest = (requset, response) ->
    response.writeHead 200, "Context-Type": "text/plain"
    response.write "hello world!"
    response.end ''
(http.createServer onRequest).listen 8888

这一段用来测试时间是否被触发的, 有时为了 favicon.ico 会多出现一次请求,

http = require "http"
onRequest = (request, response) ->
    console.log "Request received."
    response.writeHead 200,
        "Content-Type": "text/plain"
    response.write "hello world"
    response.end ''
(http.createServer onRequest).listen 8888
console.log "Server has started"

其中的 request 和 response 是 object, 可以用 cosole.log 打印查看.
写成模块 coffee 直接识别了, 注意代码中的 exports.start = start .

$ cat server.coffee
http = require "http"
start = ->
    onRequest = (requset, response) ->
        response.writeHead 200,
            "Content-Type": "text/plain"
        response.write "hi"
        response.end ''
    (http.createServer onRequest).listen 8888
    console.log "started"
exports.start = start

$ cat index.coffee
server = require "./server"
server.start ''

对于这样一个 URL,  http://localhost:8888/start?foo=bar&hello=world

url.parse(string).pathname == "start" , url.parse(string).query == "foo=bar&hello=world"

需要 url 模块, pathname = (url.parse request.url).pathname

使用 route 来将 url 执行处理的程序, 三个文件如下:

$ cat router.coffee
route = (pathname) ->
    console.log "About to route a request for " + pathname
exports.route = route
$ cat server.coffee
http = require "http"
url = require "url"
start = (route) ->
    onRequest = (request, response) ->
        pathname = (url.parse request.url).pathname
        console.log "Request for " + pathname + " received."
        route pathname
        response.writeHead 200,
            "Content-Type": "text/plain"
        response.write "hi"
        response.end ''
    (http.createServer onRequest).listen 8888
    console.log "Server has started"
exports.start = start

$ cat index.coffee
server = require "./server"
router = require "./router"
server.start router.route

接下来是写 request handlers 供 route 操作来 handle requests , $ cat requestHandlers.coffee

start = ->
    console.log "Request Handler 'start' was called."
upload = ->
    console.log "Request Handoer 'upload' was called."
exports.start = start
exports.upload = upload

然后作者讲的一大堆我理不清, 直接代码 $ cat index.coffee

server = require "./server"
router = require "./router"
requestHandlers = require "./requestHandlers"
handle =
    "/": requestHandlers.start
    "/start": requestHandlers.start
    "/upload": requestHandlers.upload
server.start router.route, handle

然后令两个文件就是改下参数添加判断, server.coffee 的改动只有关于 handle 的两行.
