
<html><head><title>Genie Notes</title>
<link rel="stylesheet" href="../global.css"/>
</head><body><pre>
不知道学 Genie 什么用场, 也许学后 C 阴影可以小些
教程地址 https://live.gnome.org/Genie
粗略的翻译可以看这里:
http://www.minghao.hk/bbs/read.php?tid=433
编写 Gtk 图形界面的教程这里:
https://live.gnome.org/GtkGuiTutorial
Genie 和 Vala 近亲, 更高级的编程形式, 内容基本类似
两者可编译到 C, 因而性能与 C 相近
使用了 GObject, 这是基于 C 的面向对象框架
http://www.ibm.com/developerworks/cn/linux/l-gobject/

Genie 的 (Hello world) 代码:
init
	print "Hello World"
程序仅两行, init 相当于 C 的 main 函数
默认用缩进来分块, 或者可以用空格, 需要指定
init
	print "Hello World"
print 后面的参数都是双引号的字符串
声明两个空格表示缩进, 默认 [indent=0]
注意! 从网页上复制代码可能使缩进变空格
注意! 源文件结尾最好有个空行, 以免可能的语法错误
发现 (Sublime Text 2) 缩进容易出问题, 改回 Vim
安装了 valac 足够版本可以用 vala 的编译器编译
$ valac hello.gs # 文件名 hello.gs 得到可执行文件
$ ./hello $ 用来执行程序
$ valac -C hello.gs # 编译到 C 源代码
看编译后的代码中类型有 gint, gboolean
注意后缀 gs, 还有和 vala 共用相同编译器
如果参数为多个文件, 编译器会自动处理依赖关系
Genie 继承了 C 大量 warning, 只好看 error

Genie 对大小写敏感
没有类型标识符, 用类型推断替代, var 声明局部变量
单行/ 多行的 var 均适用
[indent=2]
init
	var i = 1
	var
		a = "happy"
		b = "sad"
		c = "anbivalent"
	for var I = 1 to 10
		print "looping"
也可以用类型赋值, 特别定义函数用到
def addon (x : int) : int
	x += 1
	return x
init
	z : int = 3
	y : int = addon (z)
	print "%d", y
对象的实例化使用 new 关键字
init
	var o = new Object()
前置修饰符 (@) 可以借用保留字比如 @for , 后面再看
注释与 C 相同, (//) 单行, (/*...*/) 多行

支持的运算有:
=, +, -, *, /, %
++, --, 看编译结果前置后置都是可以
+=, -=, *=, /=, %=
逻辑运算符, 原文写的 "not (b)":
>, <, >=, <=, (is not), is, and, or, not
init
	if (a > 2) and (b < 2)
		print "true"
位运算符沿用 C 的语法:
|, ^, &, ~, |=, &=, ^=
比特位移:
<<=, >>=
类型相关的:
obj isa Class
条件控制语句可以加上 do 使用单行, 同样适用于 while
init
	var a = 1
	if a>0
		print "greater than 0"
	else if a is 0 
		print "is 0"
	else
		print "less than 0"
	if a > 0 do print "true"
	else do print "false"
	while a < 10 do a++
	for var i = 1 to 10 do print "i:%d", i
也有 (for s in args do print args) 的语法, 后面再看
break 和 continue 的语法照常
(case...when) 一旦遇到匹配就不再执行, 注意逗号可用
init
	var a = 3
	case a
		when 1,2
			print "1 or 2"
		when 3
			print "3"
		default
			print "else"
而且字符串作为判断条件也是可行的

Genie 的数据类型分为值类型和引用类型
值类型每次赋值时都对值进行复制(?)
引用类型不复制, 新的标识符仅引用该对象
值类型包括简单的数据类型, 还有复合的结构体
简单数据类型比如以下:
	char, uchar
	int, uint
	float, double
	bool (boolean)
	unichar (Unicode character)
	string
引用类型以类作为声明, 不必继承自 Glib 对象
系统会一直追踪索引的数量来管理内存(?, 不懂)
列表是引用类型, 就像字符串类型是 UTF-8 编码的字符串(?)

Genie 要保证引用都指向真实对象, 因此不能随便用  null
修饰符问号 (?) 放在类型之后, 运行 null 的出现, 避免错误
def fn_no_null (param : string) : string
	return param
def fn_allow_nulls (param : string?) : string
	return null
init
	var a = null
	// fn_no_null (a) // ... assertion `a != NULL' failed
	fn_allow_nulls (a)
这些检查在运行时执行, 调试完成可以个关掉, 但要看 valac 文档(?)

通常 Genie 创建对象返回一个引用
内存及对象会进行引用计数, 在无用时自动删除
弱引用就是不计入到其中, 用关键字 weak 完成
init
	class Test
		o : Object
		def get_weak_ref () : weak Object
			o = new Object ()
			return o
相应调用该方法赋值时需要指定弱引用类型
o : weak Object = get_weak_ref ()
例子 o 的复杂来源于所有权的概念
如果 o 不属于这个类, 那么方法返回的弱引用就不能被调用了
假如返回值不是弱引用, 将传给调用代码, 但弱类型不能传递所有权
弱类型像指针, 更容易结合使用, 但不需要常用

(#) 作为修饰符用来转移所有权, 避免非引用的拷贝(?)
init
	var s = "world"
	t : string = # s
	print t
	print s
最终 s 变成了 null, 而 t 继承了 s 原先的所有权

Genie 自动为创建实例返回索引, 结束时删除无用的索引
通过指针可以人工创建和销毁实例, 更好地控制内存
通常系统管理内存足够高效, 除了两种情况:
	特意优化代码某个部分
	不支持引用计数和内存管理的外部库, 比如不基于 GObject
通过在类型声明加 (*) 后缀来创建实例获得索引

调试出错, 不行, 中止
